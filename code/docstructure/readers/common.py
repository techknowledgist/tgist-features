"""

This module contains shared code for the reader modules.

"""


import shlex, codecs


class Tag():

    """
    Contains information for individual lines in a fact file. The fact file can either
    contain the BAE-generated output or the complete standoff output as generated by
    utils/standoff."""

    def __init__(self, text, fact_type):
        split_text = shlex.split(text)
        self.name = split_text[0]
        self.fact_type = fact_type
        self.attributes = dict([x.split('=', 1) for x in split_text[1:]])
        if fact_type == 'BASIC':
            p1 = self.get_basic_offset()
            length = self.get_basic_length()
            self.start_index = p1
            self.end_index = p1 + length if (p1 > -1 and length > -1) else -1
        if fact_type == 'BAE':
            self.start_index = int(self.attributes.get("START", '-1'))
            self.end_index = int(self.attributes.get("END", '-1'))

    def __str__(self):
        return "[%d %d %s type=%s]" % (self.start_index, self.end_index, self.name, 
                                       self.attributes.get('TYPE', None))
            
    def __len__(self):
        return self.end_index - self.start_index

    def __cmp__(self, other):
        if self.start_index < other.start_index: return -1
        if self.start_index > other.start_index: return 1
        if self.end_index > other.end_index: return -1
        if self.end_index < other.end_index: return 1
        return 0

    def text(self, doc):
        return doc[self.start_index:self.end_index]

    def attr(self, attr, default=None):
        return self.attributes.get(attr, default)

    def get_type(self):
        return self.attributes.get('TYPE', None)

    def set_type(self, type_value):
        self.attributes['TYPE'] = type_value
        
    def get_basic_offset(self):
        keys = [a for a in self.attributes.keys() if a.endswith(':offset')]
        return int(self.attr(keys[0], -1)) if keys else -1
    
    def get_basic_length(self):
        keys = [a for a in self.attributes.keys() if a.endswith(':length')]
        return int(self.attr(keys[0], -1)) if keys else -1
    
    def is_contained_in(self, p1, p2):
        """Return True if self is contained in p1 and p2."""
        if p1 <= self.start_index <= p2 and p1 <= self.end_index <= p2:
            return True
        return False

    def is_not_contained_in(self, p1, p2):
        """Return True if self is not contained in p1 and p2."""
        return not self.is_contained_in(p1, p2)

    def is_abstract(self):
        """Return True if self is an abstract, False otherwise. Can deal with BAE fact
        files and output of utils/standoff."""
        if self.name.lower() == 'abstract':
            return True
        if self.name == 'STRUCTURE' and self.attributes['TYPE'] == 'ABSTRACT':
            return True
        return False

    
def load_data(text_file, fact_file, fact_type='BAE'):
    """Returns a tuple of the text as a unicode string and a list of Tag instances created
    from the fact file."""
    text = codecs.open(text_file, encoding="utf-8").read()
    # tags = [ Tag(line, fact_type) for line in open(fact_file) if line.strip() != '' ]
    # The nice compact line above needed to be replaced with somehting more verbose since
    # some error handling was needed, this was added because USPP021257P2.fact in the fact
    # files for the 500 US sample patents in lexis.tgz is corrupted
    tags = []
    for line in open(fact_file):
        if line.strip() != '':
            try:
                tag = Tag(line, fact_type)
                tags.append(tag)
            except Exception, e:
                print "WARNING: could not make Tag instance from line"
                print '         [', line.rstrip(), ']'
    return text, tags


def find_abstracts(tags):
    """Returns all tags that are abstract tags."""
    return [t for t in tags if t.is_abstract()]


def load_articles(basename_file="files.txt"):
    articles = []
    for line in open(basename_file):
        basename = line.strip().split("/")[-1]
        articles.append(load_data(basename))
    return articles


def tags_with_name(tags, tagname):
    """Returns all elements from tags with name == tagname"""
    return [t for t in tags if t.name == tagname]


def tags_with_type(tags, tagtype):
    """Returns all elements from tags with type == typename"""
    return [t for t in tags if t.attributes["TYPE"] == tagtype]


def tags_with_matching_type(tags, tagtype, p1, p2):
    """Returns all elements from tags with type[p1:p2] == typename"""
    return [t for t in tags if t.attributes["TYPE"][p1:p2] == tagtype]


def open_write_file(filename, encoding='utf-8'):
    """Open a file using codecs and return the filehandle."""
    return codecs.open(filename, 'w', encoding)
