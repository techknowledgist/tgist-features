"""

Simple script to view results of processing.

Usage example:

   % python view.py elsevier-simple.txt elsevier-simple.fact out.html

   The first file is the raw text, the second is a fact file which could contain the fact
   file as generated by BAE or the sect file that s the output of the document parser. The
   third file is created by the script and contains a pretty print of the text with blue
   boxes added around the sections, headers are not marked, but the types associated with
   the section are printed in a red box preceding the section.
   
It is also quite rigid on what the expected format of the fact file is, and changes to the
input format may break this script. Expected are lines with a substring as follows:

   TYPE=<string> START=<int> END=<int>

For example:

   SECTION ID=5 TYPE="CONCLUSION" START=8912 END=9025
   STRUCTURE TYPE="TEXT" START=30901 END=30986

Another limitation is that this script does not try to do anything smart about avoiding
introduction of crossing tags. It is smart enough though (I think) to deal with correctly
embedded tags.

"""


import sys, codecs, re
import html_fragments


def createHTML(text_file, sect_file, html_file):

    fh_html = codecs.open(html_file, 'w', encoding='utf-8')
    fh_text = codecs.open(text_file, encoding='utf-8')
    fh_sect = codecs.open(sect_file, encoding='utf-8')

    (starts, ends) = create_offset_dictionaries(fh_sect)
    fh_html.write(html_fragments.HTML_PREFIX)
    text = fh_text.read()
    p = 0
    stack = []
    for char in text:
        # first try to end a tag, needs to be done in case we have a tag from position
        # p1-p2 and another from position p2-p3, opening the latter first introduces a
        # crossing tag
        if ends.has_key(p) and stack and stack[-1][1] == p:
            fh_html.write("\n<p class=offset>%d</p>\n</div>\n" % p)
            stack.pop()
        # check for opening tags
        if starts.has_key(p):
            (end, label) = starts[p]
            stack.append((p, end))
            section_type = starts[p][1]
            section_type = ' | '.join(section_type.split('|'))
            fh_html.write("\n<div class=section>\n")
            fh_html.write("\n<div class=header>%s</div>\n" % section_type)
            fh_html.write("<p class=offset>%d</p>\n" % p)
        # write the actual character
        if char == "\n":
            fh_html.write("</br>\n")
        else:
            fh_html.write(char)
        # now check for closing tag again for cases where you have a tag p1-p1
        if ends.has_key(p) and stack and stack[-1][1] == p:
            fh_html.write("\n<p class=offset>%d</p>\n</div>\n" % p)
            stack.pop()
        # also preserve newlines in html
        p += 1
    fh_html.write(html_fragments.HTML_END)
    fh_html.close()


def create_offset_dictionaries(fh):
    starts = {}
    ends = {}
    for line in fh:
        p1 = line.find('START')
        p2 = line.find('END')
        p3 = line.find('TYPE')
        if p1 == -1 or p2 == -1 or p3 == -1:
            continue
        start = line[p1+6:].split()[0] 
        end = line[p2+4:].split()[0]
        label = line[p3+5:p1].strip()
        starts[int(start)]= (int(end), label)
        ends[int(end)] = (int(start),)
    return (starts, ends)

def print_dict(filename, dictionary):
    print '==', filename
    for p in sorted(dictionary.keys()):
        print p, "==>", dictionary[p]


if __name__ == '__main__':
    (text_file, sect_file, html_file) = sys.argv[1:4]
    createHTML(text_file, sect_file, html_file)
